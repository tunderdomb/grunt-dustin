grunt-dustin
============

Better templating with LinkedIn's Dust fork for grunt

## Static API

It's undocumented because the methods are mainly utilities and called internally.
You can check the source thou, they are exposed on the `dustin` function returned by `require("grunt-dustin")`.

## Adapter API

Obtain the singleton instance:

```js

var dustin = require("grunt-dustin")
var adapter = dustin({
  cache: true,
  preserveWhiteSpace: false,
  resolve: "view/",
  resolveSrc: path.join(__dirname, "..", "view/")
})

```
### registerHelpers( sources )

Register helpers. For each path in the `sources` array, dustin does this:

```js
require(src)(adapter, dustin, dust)
```

In a helper js, you can do something like this:
```js
var fs = require("fs")
module.exports = function ( adapter, dustin, dust ){
  dust.helpers.include = function ( chunk, context, bodies, params ){
    var src = params.src
    if( !src ) return chunk
    return chunk.write(fs.readFileSync(src))
  }
}
```

You have access to the adapter singleton, so you can call its methods.

### data( sources )

Attach json data to the adapter's default context.
For each path in `sources` dustin does this:

```js
context[dustin.nameOf(file)] = JSON.parse(dustin.read(file))
```

So in a template you can reference global object with the filename it is from.

Example:
team.json
```json
[
  {"name": "Tony"},
  {"name": "Mary"}
]
```

```html
{#team}
  {name}
{/team}
```

```html
Tony
Mary
```

### render( src, content, context, done )

Render a template string with a given context. This object is merged with the adapter's
default context object setup with `data(sources)`.
The context can be null too, then the default is used without merging.
The `src` argument is only used so an error can report which root template

### compile( src, content, done )

Compile a template string, and figure out its name from `src`.
call `done(null, compiled)` where `compiled = dust.compile(content, name)`.

### renderView( src, res, next, content, context )

Internal method used to render a template for a route generated by `addView`.

### addView( app, url, src, context )

This method relies on the `resolveSrc` options passed to the `Adapter` constructor
to load dust templates from the file system and serve them on a route using an express app.
Inside the generated route it calls `renderView`.

## Grunt task

```js

  grunt.initConfig({
    dustin: {
      // set global values for path resolution
      options: {
        resolve: "test/partials/",
        partials: "**/*.dust",
        setup: function( adapter, dust ){}
      },
      copyClientLibs: {
        options: {
          // if the client option is present, every other is ignored
          // copy client libs to this dir
          client: "test/lib/",
          // set path resolution to this path
          // templates will attempt to load from this dir
          // example: {>"nested/partial/go"/}
          // will load from compiled/partials/nested/partial/go.js

          // NOTE: for correct resolution, the compiled templates must use the same resolve roots,
          // so take care setting the resolve and partials options accordingly
          // In a nutshell, the resolve option just lets you define a resolution root
          // so you can refer to templates with a relative path.
          resolve: "compiled/partials/"
        }
      },
      render: {
        options: {
          // this target renders html files
          render: true,
          // Dust removes white space by default. Don't do that.
          preserveWhiteSpace: true,
          // create a global context from these json files
          // file names will be global properties
          data: "test/data/*.json",
          // execute these js files and let them register helpers
          helpers: "test/helpers/*.js"
        },
        expand: true,
        cwd: "test/templates",
        src: ["*.dust"],
        dest: "test/rendered/"
      },
      compile: {
        options: {
          // this task compiles js files
          compile: true,
          // we don't care about white space in compiled templates
          preserveWhiteSpace: false
        },
        expand: true,
        cwd: "test/",
        src: ["**/*.dust"],
        dest: "test/compiled/",
        ext: ".js"
      },
      compileAndConcat: {
        options: {
          preserveWhiteSpace: false,
          compile: true,
          // this one concats compiled files into one
          concat: true
        },
        files: {
          "test/compiled/partials.dust.js": "test/partials/**/*.dust",
          "test/compiled/templates.dust.js": "test/templates/**/*.dust"
        }
      }
    },
    clean: {
      test: {
        src:[
          "test/rendered/**/*",
          "test/compiled/**/*"
        ]
      }
    },
    dir: {
      "src": {
        src: "test/templates/*.*"
      },
      "src-dest": {
        src: "test/templates/*.*",
        dest: "test/rendered"
      },
      "src-expand": {
        expand: true,
        src: "test/templates/*.*"
      },
      "src-dest-expand": {
        expand: true,
        src: "test/templates/*.*",
        dest: "test/rendered"
      },
      "cwd-src-dest-expand": {
        expand: true,
        cwd: "test/templates/",
        src: "*.*",
        dest: "test/rendered"
      }
    }
  })
```

## Licence

MIT